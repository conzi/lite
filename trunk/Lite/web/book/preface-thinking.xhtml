<html xmlns="http://www.w3.org/1999/xhtml"
	xmlns:c="http://www.xidea.org/ns/lite/core"
	xmlns:fk="http://www.xidea.org/ns/lite/example">
	<head>
		<title>模板传奇---模板编程思想介绍</title>
	</head>
	<body>
	<h2>前身今世</h2>
		<c:include path="preface-history.xhtml" xpath="//xhtml:body/*"/>
		<h3>为什么需要模板</h3>
		<h3>视图只是一个传说</h3>
		<img src="webmvc.png" align="right" title="Web MVC 模块关系图" />
		<p>
			不要迷信哥，哥只是一个传说。你也有理由不相信视图，因为视图也只是一个传说。
		</p>
		<p>
			然而，在程序世界中，我们最重要的信息来源，就是视图。他是人机交互中计算机提供的数据的终点。我们通常也只能通过各种不同的试图来获知计算机中数据的状态。
		</p><p>
			视图是MVC模式中最另类最清晰的一层，它是程序中最无害的展现逻辑；它有明确的职责：展示给用户一个当前状态的快照。
			由于展现只是一个快照，她的改变不会影响程序行为，视图上的数据就像是加了一个类似ReadOnly的约束，
			如此约定让视图层变成了一个可以让人放心的模块。这样视图模块的开发人员甚至可以由UI设计等非专业编程人员担任，
			这样的定位使得视图的编程语言有了一个更加独特的的方向发展，于是有了标记语言，模板语言的发展。
			他们的出现，真正把核心逻辑从繁琐的展现逻辑中解脱出来。
		</p>
		<h3>视图是单向的数据流</h3>
		<p>在程序世界，通常一个模块可以在任意时候从其他任何地方获取数据，其他地方也随时可能向他获取数据。
		但是视图模块例外，视图只能读取外界给他的数据，他不能主动调用外部数据，外部程序也不能干预视图自身的逻辑。只能将数据交给视图。
		</p>
		<h3>面向原始数据编程</h3>
		<p>
			MVC非常有价值的一点就是她的视图概念的抽取，视图层因为其面向用户这一特点，面向用户的数据一般都会有较多的静态修饰数据（如用来增强视觉效果的图像，颜色）和较高的冗余数据（比如大量通过循环输出的静态标记语言）。
			我们如果针对这种高度冗余的数据编程，很容易出现大量重复的代码，稍有不慎就可能出现数据不一致的问题，而这些问题将逐步把程序维护推向地狱。
		</p>
		<p>
			此外:
			<pre>
				<strong>数据 + 模板==>视图</strong>
			</pre>
		</p>
		<p>通过这一公式我们可以看到，视图本身就是一种冗余数据，他是由原始数据生成的数据。</p>

		<p>
			<i>
				与人的交互和与机器交互，是两个个差异很大的问题，面向机器的接口就是应该统一，无冗余无废话。
				然而，面向人的接口，我们的信息就是不断的重复，不断的提示，高度的冗余通常就是造就更好的用户体验的基础。
				然而，程序设计中，冗余就是大忌，这不是存储空间的问题，冗余最容易引发的问题就是数据不一致。
				导致程序的可维护性极低。

				如果要解决这种问题，我们就要设计更高范式的数据模型。 从数据模型上杜绝冗余的可能。
			</i>
		</p>
		<p>
			很多人一说到前端编程，第一印象就是脏累繁。
			这是为什么呢？浏览器的问题这里暂且不论。提一点您可能没有重视的：您可能选错了编程对象。
		</p>
		<p>
			错在哪里？ 问题就在DOM数据是否总是适合作为程序直接控制的数据模型？
			DOM是被生成的数据，被生成的数据通常都容易有更多的冗余（前端数据的冗余也就是jQuery这种面向集合的编程方法流行的原因之一）。
			以前的网页都很简单，我们基本没有抽象数据模型的必要，我们一直都将就着。

			但是随着程序逻辑的不断复杂化。DOM节点作为数据模型，就显得有点臃肿了。很明显，他不够简单抽象，有了太多显示的细节，太多重复的定义。
		</p>
		<p>
			然而目前，前端代码就是在不断反复的折腾这些DOM节点。 如果我们能再文档对象模型之上再次抽取一种更加干净的数据模型，
			我们能直接修改原始数据，直接通过操纵这种用来生成文档对象模型的原始数据，可能一切就会更加简单了。
		</p>
		<p>
			<i>其实针对DOM编程的做法并不一定是错的，但不要一叶障目。有些时候，换一种思维，就会有另外一片天地。</i>
		</p>

		<p>那么面向数据的编程有那些要点呢？</p>
		<ul>
			<li>以数据为中心：去繁就简,返朴归真</li>
			<li>大乱需大治：表现层没有上下文，一切修改从源头出发。</li>
		</ul>

		<p>好了，这就是我们要解决的问题，不要在显示层面编程，要对数据编程。</p>
		<p>相同的道理同样适用于后端开发。</p>
		
		
		<h3>基于模板的视图层编程</h3>
		<h4>模板语言的特点</h4>
		<p>
			模板的本质就是：从原始数据（一个结构化的数据，如json，javabean和java集合，php数组和关联数组）通过特定规则生成一个目标数据（如html）；再说的通俗一点，那就是模板就是的工作就是把我们给出的数据拼成一个字符串。
		</p>
		<p>那么模板源码有哪些表现特征呢？</p>
		<ul>
			<li>
				模板源码接近目标代码

				<i>
					<p>这样既有利于人工的阅读排错，也有利于ide的识别。</p>
					<p>
						XSLT就是反例，他源码与输出结果结构差别太大，关联太多，程序风格更像一中新的编程语言，而不是模板语言，这也正是XSLT失败的关键一点。
					</p>
				</i>
			</li>
			<li>
				模板源代码一般独立存在
				<p>
					<i>独立的文件有利于IDE更好的支持，有利于编辑器和文件类型的关联。</i>
				</p>
			</li>
		</ul>
		<p>除了这些外在特征，模板编程元素有哪些呢？</p>
		<ul>
			<li>
				表达式
				<i>
					<p>
						从程序员的角度看表达式：他很像我们写程序的时候，
						<strong>=</strong>
						操作符右边允许出现的那些语法元素。
						他是变量、常量、操作符三种基本语法元素的组合（函数调用也可以描述成操作符的运算）。
					</p>
					<p>
						从模板架构的角度看表达式：他是模板与数据模型之间唯一直接关联的元素。所有与动态内容都可以通过表达式从数据模型中获得需要的数据（可能还能执行一些只读运算）
					</p>
				</i>
			</li>
			<li>
				控制语法
				<i>
					<p>模板也会允许一些简单的控制语法，比如条件，循环，甚至零时变量申明。</p>
					<p>
						控制语法中一般也包含表达式语法，表达式从数据模型中获得数据，控制语法更具这些数据完成循环，条件判断等操作逻辑。
					</p>
				</i>
			</li>
			<li>
				资源组织语法
				<i>
					<p>
						类似程序语言中的include，import语法，模板语言中也有这类用来管理模板资源的语法，而且可能功能更加强大，文件包含，文档片段包含，继承包含，等等...
					</p>
				</i>
			</li>
		</ul>
		<h4>模板编程步骤</h4>
		<p>模板编程要设计到底需要做什么？怎么做？我们总结了一个常见的步骤如下：</p>
		<ul>
			<li>静态原型设计
			<p>拿到ui设计稿之后，你首先需要规划好您的静态展现方式。不同的展现元素，你计划如何实现？html结构规划？样式单设计？你最好应该先将静态内容写好，当能，这里你也可以借助ui设计器。</p></li>
			<li>数据接口的设计
			<p>在有了静态数据规划之后，你需要总结模板中动态的内容的数据结构。
			并编写相关的模拟数据（比如一个JSON数据，他同时也是一个很好的文档）。这一步你还需要与与你合作的后端工程师共同协商。</p></li>
			<li>动态模板语法加入
			<p>数据接口和静态原型都有了之后，你就可以在原型的基础上。将动态内容替换成模板语法。并在测试环境上随时修改随时预览。不断优化。</p></li>
			<li>与后端工程师联合调试
			<p>前面的工作完成之后。剩下的就是连接真实环境调试，一切正常就算任务完成了。</p></li>
		</ul>
		<h4>服务端模板</h4>
		<p>服务端网页输出的时候，模板技术已经是非常成熟了，这点不必多做解释，模板+数据就是我们需要的展现代码（html）。</p>

		<h4>前端模板</h4>

		<p>
			目前的前端编程还处在一个混沌的时期，前端的业务和展示混杂在一起，浑浑沌沌，暗无天日。
			要解决这个问题前端模板的运用无疑是一个很好的办法。
		</p>
		<p>虽然模板技术再后端发展欣欣向荣，可是再前端就是少有叫好，没有叫座的,为什么呢？</p>
		<p>因为前端模板还没有真正成熟的技术，现行的技术存在严重的问题，这主要包括：</p>
		<ul>
			<li>庞大的实现是个死穴</li>
			<li>重复编译让费系统资源</li>
			<li>环境的苛刻，附加的类库 把它拖累</li>
		</ul>
		<p>若要解决这些问题，我们需要一个前端模板的平台，而服务端模板系统，就可以作为这个平台的提供方。</p>
	</body>
	<!--  老草稿 -->


	<c:comment>
		<p>
			在前一章介绍模板发展的过程中，我们重点提到一个简化问题的方法，那就是"分"。
			其实，分只是外表，只是方法，并不是我们的最终目的。 MVC的本质不是分，MVC的初衷也不是分工合作。
		</p>
		<p>
			任何时候，检验改革成败的唯一标准就是提高生产率，是的，分的目标也就是简化我们的程序逻辑，提高我们的开发效率。
			然而分首先是有害的。他增加模块间接口，可能导致沟通成本或者编码切换成本的上升，降低我们的开发效率。

			不合理的分，过度的分，通常会适得其反，所以，
			<strong>只要我们不能从分的结果中收获足够的好处，就不要轻言分离</strong>
			。
		</p>
		<p>上面这些文字，目标只有一个，那就是说，"分"不是万能的。不过，事实也告诉我们MVC的分，是成功的：</p>

		<p>
			MVC模式首先将程序中最多变的最无害的展现逻辑分离出来；并且明确视图的职责：展示给用户的一个当前状态的快照。
			由于展现只是一个快照，她的改变不会影响程序行为，这种职能的确定，更有利于展现模块向更适合自身的方向发展，进而有了标记语言，模板语言的发展。
			同时，这一过程也把核心逻辑从繁琐的展现逻辑中解脱出来。
		</p>
		<p>
			抽取显示逻辑之后，核心逻辑中依然带有大量与展示衔接的代码，这样，她依然不利于更加合理的核心结构的设计。
			于是，我们从核心逻辑中将与前端交互相关的部分再次抽取，这就是控制逻辑。

			经过两次简化，分别给表现层和核心逻辑减负，让他们可以抛开交互逻辑轻装前行。
		</p>
		<p>
			总结一下MVC成功的理由：
			<ul>
				<li>
					M，V，C三者分离之后，各自的职能都变得更窄更专业
					<p>
						这让各自抛开外部包袱，可以在自己专业领域轻装前行，自由发展。比如，没有视图的分离，就不会有模板语言的发展。
					</p>
				</li>
				<li>
					M，V，C三者分离之后，相互之间的接口变得简单清晰统一
					<p>
						MVC的分离，并不是硬生生的剥离。他是按照各自职能顺其自然的划分。
						<p>
							<i>
								Struts1的action 和
								formbean分离就是一个反例，因为formbean与Action之间过度紧密的关联，导致分离之后只是复杂了模块接口而没能获得多少实惠，同一个功能必须跳到好几个地方修改，而且这些关联都是通过一大堆自定义的xml配置建立，非常不利于IDE的协助，让开发更加麻烦。
							</i>
						</p>
					</p>
				</li>
				<li>
					视图被分离的同时，加上了一个类似ReadOnly的约束
					<p>
						如此约定让View变成了一个可以让人放心的模块。让视图模块的开发人员可以由ui设计人员等非专业编程人员担任，使得分工更加合理。
					</p>
				</li>
			</ul>
		</p>
	</c:comment>
</html>
