#labels Featured
==基于XML 解析器的模板的语法亮点==
  * XML严谨的代码风格有利于培养程序员良好的编程习惯。
    前端程序员在程序结构完美上的追求普遍很低，使用XML模板引擎有利于程序员养成严谨的编码风格，以及追求代码结构完美的习惯。

  * XML自身语法约束可以协助程序员更高效的编码。
    选项太多，往往使人茫然，增加错误；合理的约束对编码效率的提高有他有利的一面。

  * XML结构模板有利于保证输出页面结构的完整性。
    XML 本身的良好严谨的结构要求，使得输出结构的也更容易保持正确的结构，减少大量代码结构上的低级错误，*减少因个别程序员的粗心而导致的XSS漏洞*。

  * 简单的自动化的编码处理和语法优化。
    见实例对比
  * 开速安全的格式化和语法空白的自动压缩
    XML规范的语法，对于代码的正确格式化非常有利，而且，也不必担心源代码中过多的语法空白而导致输出内容的增加，因为xml语言知道标记语言的语法，可以自动优化无效的语法空白。

  * 文档片断级的代码复用。
    基于xpath的片段选取，可以将密切关联的若干模版碎片集中存放，并反复利用。
    如，我们可以吧Webwork的自定义标记定义在一个完整的表单对象中。

  * 可以轻松实现装饰模版。
    PageMesh 功能，编译期的SiteMesh。轻松实现高校的页面装饰功能（布局管理）。
    细节见：http://code.google.com/p/lite/wiki/XML_Lite_PageMesh

  * 通过XSD文件，可以很好的利用通用XML编辑器。
    引入XML语法描述文件后，标准的通用编辑器可以轻松的支持XML_Lite自己的*语法提示* ，*语法检查* ，*代码高亮* 、*格式化* 。

== 与Velocity,JSTL 对比对比 ==

<table border="1" cellspacing="2" cellpadding="0"><tr>
<th width="80">实现功能</th><th>Lite XML</th><th>Velocity / JSTL... </th></tr>

<tr valign="top"><th>添加两个可选属性</th><td>
{{{
<input
  onclick ="${action.click}"
  ondblclick="${action.dblclick}" >
}}}
</td><td>
  * Velocity
{{{
<input 
#if(${action.click!=null})
onclick="${html.encode(action.click)}" 
#end
#if(${action.dblclick!=null})
ondblclick="${html.encode(action.dblclick)}"
#end>
}}}
  * JSTL
{{{
<input 
  <c:if test="${action.click!=null}">
    onclick= "<c:out
                 value="${action.click}"
                 escapeXml="true" />"
  </c:if>
  <c:if test="${action.dblclick!=null}">
    onclick= "<c:out
                 value="${action.dblclick}"
                 escapeXml="true" />"
  </c:if>
>
}}}
</td>
</tr>

<tr valign="top"><th>填充checkbox选中状态(启用AutoForm)</th><td>
{{{
<input type="checkbox"
       name="flag" 
       value="true">
}}}
</td><td>
 * Velocity
{{{
<input type="checkbox"
       name="flag"  
       value="true"
       #if(${flag})
       checked="checked"
       #end>
}}}
 * JSTL
{{{
<input type="checkbox"
       name="flag"  
       value="true"
       <c:if test="${checked}">
       checked="checked"
       </c:if>
>
}}}
</td></tr>

<tr valign="top"><th>填充select选中状态(启用AutoForm)</th><td>
{{{
<select name="keys"
        multiple="multiple">
  <option value="23213">商品1</option>
  <option value="2345">商品2</option>
  <option value="235656">商品3</option>
</select>
}}}
</td><td>
 * Velocity
{{{
<select name="keys"
        multiple="multiple">
  <option value="23213" 
#if(${ArrayUtil.contains($keys,23213)}) selected="selected"
#end>商品1</option>
  <option value="2345" 
#if(${ArrayUtil.contains($keys,2345)}) selected="selected"
#end>商品2</option>
  <option value="235656" 
#if(${ArrayUtil.contains($keys,235656)}) selected="selected"
#end>商品3</option>
</select>
}}}
 * JSTL
{{{
<select name="keys"
        multiple="multiple">
  <option value="23213"
 <c:if test="${myfn:contains(keys,23213)}">
 selected="selected"</c:if>>商品1</option>
  <option value="2345"
 <c:if test="${myfn:contains(keys,2345)}">
 selected="selected"</c:if>商品2</option>
  <option value="235656"
 <c:if test="${myfn:contains(keys,235656)}">
 selected="selected"</c:if>>商品3</option>
</select>
}}}
</td></tr>


</table>
== XML Lite 的其他语法亮点 ==
  * 设计简单
    相比于传统的模板引擎，XMLLite最大的优点就是他的设计简单。
    类似JSP EL的表达式，类似JSTL的控制标签，各自独立，结构清晰，概念简单。

  * 表达式和逻辑控制分离。
    Lite默认的表达式实现是JSEL，一个按照JS运算规则设计的简单的表达式运算引擎。这也是Lite之所以能在前后端公用同一语法的基础。
    而XML Lite的逻辑控制指令，在解脱了表达式解析负担之后，设计也得到了极大的简化。
    因为表达式和逻辑控制的分离，使得任何一个模块都可以独立运作，抛开模板，表达式解析功能可以用于其他系统，抛开默认的JSEL，我们可以采用其他任何一种自己喜欢的表达式运算规则。

  * 简单的中间格式便于跨平台存储和跨平台运行环境的实现
    JSEL，以及Lite的数据结构，只是一种简单类型和列表类型的组合，是JSON的一个子集，自己可直接被JSEL自身功能实现数据装载解析。

  * else 可直接作用于循环标记。
    受CommonTemplate启发，在做表格输出的时候，经常碰见这样一种情况，当没有任何结果的时候，显示一个没有任何记录的提示，类似这种问题，你就直接用else吧。

  * 直接利用for 关键字。
    受CommonTemplate启发，for作为关键字，用来表示循环状态，不让废变量空间，意思又简单明了。

  * 实现简单，库文件总共不过100k。
    相比于其他模板引擎动辄上M几百k，Lite加上解析器也不过百k，小巧精悍。
  * 跨语言平台。
    目前已支持Java，JS，Python。